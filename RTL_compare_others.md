# 基于RTL的函数调用信息获取方法和其他静态分析方法的比较

1.  可以通过readelf -s  vmlinux从符号表里面，得到内核定义了哪些函数，包括.c 和.S文件里面的函数。可以根据objdump -d反汇编结果得到哪些函数调用了哪些函数。包括.c和.S里面的函数相互调用。通过addr2line也可以知道函数调用发生在源代码的哪个文件的哪一行。
 

1.   但是objdump  -d的结果有时候有可能不准确。有的特殊代码会在代码段中掺杂数据，会导致objdump -d 把数据当中指令去反汇编，导致反汇编结果错误，或者反汇编失败。此时获取的调用信息就不准确或者无法获取函数调用信息了。


1.  RTL也可以获取到函数的调用信息。哪个函数在源代码哪一行调用了哪个函数。 也可以根据编译器信息知道，各个函数在源代码的开始行号。

1. RTL和比反汇编vmlinux的方法的区别是：从源代码获取信息始终是可以的，不会存在不准确或者失败的情况。从vmlinux里面不但可以获取到函数符号信息，而且还可以获取到，符号的定义地址，函数调用发生的地址。


1. 使用-fdump-rtl-sched2 选项只能获取-O2和-O3阶段的RTL中间结果。

1. 从AST里面也可以获取函数调用信息，比RTL的方法更靠前。

1.  从AST,RTL都无法获取.S文件中的函数调用信息。因为.S文件不存在编译过程，不会产生AST和RTL中间表示形式。

1. AST和RTL和反汇编结果，都会受到函数的inline 和编译器的-ON优化影响，导致获取的有些获取的信息和源代码对应不上。 例如inline导致函数消失了， 优化会多出一些函数来。如果去掉编译优化和函数的inline属性，得到的静态分析结果会更全面。

1. 从AST也可以获取到函数有哪些参数，参数类型是什么(,RTL方法也可以但是没有AST方法方便)。但是无法获取其访问方法，存放位置。

1. 符号表和调试信息也是编译器从编译的过程中收集过来的，如果用来进行调试，结果会更准确。例如调试信息里面记录了各个函数的参数存放位置，以及局部变量、全局变量等等的存放位置。如果使用-g3/-ggdb3更会记录宏定义的信息。

1. 编译器不同阶段收集的信息，用途不同。AST,RLT的分析结果适合静态分析用。vmlinux的符号表和调试信息里面的分析结果更适合调试用。

